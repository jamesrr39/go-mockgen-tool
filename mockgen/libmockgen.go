package mockgen

import (
	"errors"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"strings"
)

var ErrInterfaceTypeNotFound = errors.New("interface type not found")

type TypeData struct {
	PackageName string
	Methods     []Method
}

type Method struct {
	Name      string
	Params    []string
	Signature string
}

func GetMethodsForType(sourceCode, interfaceName string) (*TypeData, error) {
	parsedFile, err := parser.ParseFile(token.NewFileSet(), "", sourceCode, 0)
	if err != nil {
		return nil, err
	}

	var itemNameFound bool

	typeData := &TypeData{
		PackageName: parsedFile.Name.Name,
		Methods:     nil,
	}

	ast.Inspect(parsedFile, func(node ast.Node) bool {
		switch n := node.(type) {
		case *ast.Ident:
			if n.Name == interfaceName {
				itemNameFound = true
			}
		case *ast.InterfaceType:
			if itemNameFound == false {
				// not the interface we are looking for, skip
				return true
			}

			for _, astField := range n.Methods.List {
				var names []string
				for _, name := range astField.Names {
					names = append(names, name.String())
				}

				var paramNames []string

				switch t := astField.Type.(type) {
				case *ast.FuncType:
					for _, param := range t.Params.List {
						for _, name := range param.Names {
							paramNames = append(paramNames, name.Name)
						}
					}
				}

				signature := sourceCode[astField.Type.Pos()-1 : astField.Type.End()-1]

				for _, name := range names {
					typeData.Methods = append(typeData.Methods, Method{name, paramNames, signature})
				}
			}
			return false
		}

		return true
	})

	if !itemNameFound {
		return nil, ErrInterfaceTypeNotFound
	}

	return typeData, nil
}

func WriteMockType(interfaceName string, typeData *TypeData) string {
	packageDef := fmt.Sprintf("// Code generated by go-mockgen-tool: https://github.com/jamesrr39/go-mockgen-tool. DO NOT EDIT!\n\npackage %s\n\n", typeData.PackageName)

	structDef := fmt.Sprintf("type Mock%s struct {\n", interfaceName)
	for _, method := range typeData.Methods {
		structDef += fmt.Sprintf("\t%sFunc func%s\n", method.Name, method.Signature)
	}
	structDef += fmt.Sprintln("}")

	var methodsDef string
	for _, method := range typeData.Methods {
		methodsDef += fmt.Sprintf(`
func(o *Mock%s) %s%s {
	if o.%sFunc == nil {
		panic("o.%sFunc not defined")
	}
	return o.%sFunc(%s)
}
`, interfaceName, method.Name, method.Signature,
			method.Name,
			method.Name,
			method.Name,
			strings.Join(method.Params, ", "))
	}

	return packageDef + structDef + methodsDef
}
